
define('AssetLoader',[],function () {
    

    function AssetLoader() {
        this.images = [];
        this.queue = {
            'images': []
        };
    }

    AssetLoader.prototype.add = function (type, key, path) {
        var item = {
            'key':  key,
            'path': path
        };
        if (type === 'image') {
            this.queue.images.push(item);
        }
    };

    AssetLoader.prototype.load = function () {
        try {
            if (this.queue.images.length === 0 && this.queue.sounds.length === 0) {
                throw new Error('No assets found to load');
            }
            for (var i = 0; i < this.queue.images.length; i++) {
                var image = new Image();
                image.src = this.queue.images[i].path;
                this.images[this.queue.images[i].key] = image;
            }
        } catch (e) {
            console.error(e.message);
        } finally {
            this.queue.images = [];
        }
        document.dispatchEvent(new Event('hasLoaded'));
        return this;
    };

    AssetLoader.prototype.get = function (key) {
        try {
            if (this.images[key] === undefined) {
                throw new Error('No asset found with the key: ' + key);
            } else {
                return this.images[key];
            }
        } catch (e) {
            throw new Error(e.message);
        }
    };

    return AssetLoader;
});

define('Renderer',[],function () {
    

    function Renderer(width, height) {
        this.width = width;
        this.height = height;
        this.renderHotspots = false;
        this.screen = null;

        this.canvas = document.createElement('canvas');
        this.canvas.id = 'cags-viewport';
        this.canvas.width = this.width;
        this.canvas.height = this.height;
        document.body.appendChild(this.canvas);
        this.context = this.canvas.getContext('2d');
    }

    Renderer.prototype.clear = function () {
        return this;
    };

    Renderer.prototype.draw = function () {
        this.clear();
        if (this.screen === null) {
            throw new Error('No Screen exists to render.');
        }
        this.context.drawImage(this.screen.getBackground(), 0, 0);
    };

    Renderer.prototype.setScreen = function (screen) {
        this.screen = screen;
    };

    return Renderer;
});

define('Screen',[],function () {
    

    function Screen(background) {
        this.background = background;
        this.hotspots = [];
    }

    Screen.prototype.getBackground = function () {
        return this.background;
    };

    Screen.prototype.addHotspot = function (hotspot) {
        this.hotspots.push(hotspot);
        return this;
    };

    Screen.prototype.removeHotspot = function (hotspot) {
        this.hotspots.splice(hotspot, 1);
        return this;
    };

    return Screen;
});

define('Point',[],function () {
    

    function Point(x, y) {
        this.x = x;
        this.y = y;
    }

    return Point;
});

define('Creature',[
    'Point'
], function (
    Point
) {
    

    function Creature(position, animationSet) {
        this.position = position;
        this.animationSet = animationSet;
        this.tileWidth = null;
        this.tileHeight = null;
    }

    return Creature;
});

define('Player',[
    'Creature'
], function (
    Creature
) {
    

    Player.prototype = new Creature();
    Player.prototype.constructor = Player;

    function Player(position, animationSet) {
        Creature.call(this, position, animationSet);
        this.inventory = [];
        this.speed = 3;
        this.destination = this.position;
        this.currentAnimation = this.animationSet.walking;
    }

    Player.prototype.load = function () {

    };

    Player.prototype.save = function () {

    };

    Player.prototype.draw = function (context) {
        this.currentAnimation.draw(context, this.position.x, this.position.y);
    };

    Player.prototype.moveTo = function (point) {
        this.destination = point;
    };

    Player.prototype.update = function () {
        this.currentAnimation.update();
        if (this.position.x !== this.destination.x && this.position.y !== this.destination.y) {
            this.currentAnimation = this.animationSet.walking;
            if (this.position.x > this.destination.x) {
                this.position.x -= this.speed;
            }
            if (this.position.y > this.destination.y) {
                this.position.y -= this.speed;
            }
            if (this.position.x < this.destination.x) {
                this.position.x += this.speed;
            }
            if (this.position.y < this.destination.y) {
                this.position.y += this.speed;
            }
        } else {
            console.log('idle');
            this.currentAnimation = this.animationSet.idle;
        }
    };

    return Player;
});

define('Input',[
    'Point'
], function (
    Point
) {
    

    function Input(canvas, player) {
        this.canvas = canvas;
        this.player = player;
        this.eventHandlers();
    }

    Input.prototype.eventHandlers = function () {
        this.canvas.addEventListener('mousedown', this.mouseDown.bind(this), false);
        this.canvas.addEventListener('mouseup', this.mouseUp.bind(this), false);
    };

    Input.prototype.mouseDown = function () {

    };

    Input.prototype.mouseUp = function (event) {
        this.player.moveTo(new Point(event.offsetX, event.offsetY));
    };

    return Input;
});

define('Animation',[],function () {
    

    function Animation(spritesheet, row, frames, tileWidth, tileHeight) {
        this.spritesheet = spritesheet;
        this.row = row;
        this.frames = frames;
        this.currentFrame = 0;
        this.animationDelay = 0;
        this.tileWidth = tileWidth;
        this.tileHeight = tileHeight;
    }

    Animation.prototype.update = function (context, x, y) {
        if (this.frames === 0) { return; }
        if (this.animationDelay === 5) {
            if (this.currentFrame < this.frames) {
                this.currentFrame++;
            } else {
                this.currentFrame = 0;
            }
            this.animationDelay = 0;
        } else {
            this.animationDelay++;
        }
    };

    Animation.prototype.draw = function (context, x, y) {
        context.drawImage(this.spritesheet, this.currentFrame * this.tileWidth, this.row, this.tileWidth, this.tileHeight, x - (this.tileWidth / 2), y - this.tileHeight, this.tileWidth, this.tileHeight);
    };

    return Animation;
});


define('AnimationSet',[
    'Animation'
], function (
    Animation
) {
    

    function AnimationSet(spritesheet, tileWidth, tileHeight) {
        this.walking = new Animation(spritesheet, 0, 3, tileWidth, tileHeight);
        this.idle = new Animation(spritesheet, 0, 0, tileWidth, tileHeight);
    }

    return AnimationSet;
});

define('CAGS',[
    'AssetLoader',
    'Renderer',
    'Screen',
    'Point',
    'Player',
    'Input',
    'AnimationSet'
], function (
    AssetLoader,
    Renderer,
    Screen,
    Point,
    Player,
    Input,
    AnimationSet
) {
    

    function CAGS() {
        this.renderer = new Renderer(640, 480);
        this.polyfillAnimationFrame();
        this.eventListeners();

        this.assets = new AssetLoader();
        this.assets.add('image', 'test-background', '/assets/img/test-back.png');
        this.assets.add('image', 'test-spritesheet', '/assets/img/test-sprite.png');
        this.assets.load();
    }

    CAGS.prototype.afterLoad = function () {
        this.renderer.setScreen(new Screen(this.assets.get('test-background')));
        this.player = new Player(new Point(0, 0), new AnimationSet(this.assets.get('test-spritesheet'), 20, 30));
        this.input = new Input(this.renderer.canvas, this.player);
        this.loop();
    };

    CAGS.prototype.eventListeners = function () {
        var _this = this;
        document.addEventListener('hasLoaded', function () {
            _this.afterLoad();
        });
    };

    // RequestAnimationFrame polyfill by Paul Irish
    // http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/
    CAGS.prototype.polyfillAnimationFrame = function () {
        var lastTime = 0;
        var vendors = ['webkit', 'moz'];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
            window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
            window.cancelAnimationFrame =
              window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = function(callback, element) {
                var currTime = new Date().getTime();
                var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                var id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            };
        }
        if (!window.cancelAnimationFrame) {
            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            };
        }
    };

    CAGS.prototype.loop = function () {
        try {
            this.update();
            this.draw();
            requestAnimationFrame(this.loop.bind(this));
        } catch (e) {
            console.error(e.message);
        }
    };

    CAGS.prototype.update = function () {
        this.player.update();
    };

    CAGS.prototype.draw = function () {
        try {
            this.renderer.draw();
            this.player.draw(this.renderer.context);
        } catch (e) {
            throw new Error(e);
        }
    };

    return CAGS;

});

require([
    'CAGS'
], function (
    CAGS
) {
    

    (function () {
        window.cags = new CAGS();
    })();
});


define("main", function(){});
